#!/usr/bin/env node

const program = require('commander');
const fs = require('fs');
const path = require('path');
const low = require('lowdb');
const FileSync = require('lowdb/adapters/FileSync');
const CLIENT_DB_PATH = path.join(__dirname, 'client-db');
const { CosmosThreshSigClient, getBalance, mnemonicTransfer, getTxInfo, getTransactions } = require('../dist/src');
const { Address, AccAddress} = require('../dist/src');

const terra = require('@terra-money/core');

const client = new CosmosThreshSigClient();

function ensureDirSync(dirpath) {
    try {
        fs.mkdirSync(dirpath, { recursive: true });
    } catch (err) {
        if (err.code !== 'EEXIST') throw err;
    }
}

function mnemonicToAddress(mnemonic) {
    const masterKey = terra.deriveMasterKeySync(mnemonic);
    const keypair = terra.deriveKeypair(masterKey);
    const address = AccAddress.fromPublicKey(keypair.publicKey);
    return address.toBech32();
}

function mnemonicToPrivateKey(mnemonic) {
    const masterKey = terra.deriveMasterKeySync(mnemonic);
    const keypair = terra.deriveKeypair(masterKey);
    return keypair.privateKey;
}


ensureDirSync(CLIENT_DB_PATH);
const adapter = new FileSync(path.join(CLIENT_DB_PATH, 'db.json'));
const db = low(adapter);
db.defaults({ addresses: [] }).write();

program
    .command('address')
    .option('-i, --index <index>', 'Address index')
    .action(async (options) => {
        await client.init();
        const address = client.getAddress(options.index);
        console.log(address);
    });

program
    .command('mnemonic_address')
    .action( () => {
        const mnemonic = terra.generateMnemonic();
        const address = mnemonicToAddress(mnemonic);
        console.log(address);
        db.get('addresses').push({ address, mnemonic }).write();
    });

program
    .command('balance <address>')
    .option('-n, --network [name]', 'Name of network ("gaia" or "columbus_2")')
    .action(async (address, options) => {
        console.log(await getBalance(address, options.network || 'gaia'));
    });

program
    .command('tx <txhash>')
    .option('-n, --network [name]', 'Name of network ("gaia" or "columbus_2")')
    .action(async (txhash, options) => {
        console.log(await getTxInfo(txhash, options.network || 'gaia'));
    });

program
    .command('transactions')
    .option('-a --action <action>', 'transaction side, Allowed values: [send, receive]')
    .option('-s --sender <sender>', 'Sender address')
    .option('-p --page <page>', 'Page number')
    .option('-l --limit <limit>', 'Page limit')
    .option('-n, --network [name]', 'Name of network ("vodka" or "columbus_2")')
    .action(async (options) => {
        const txs = await getTransactions(options);
        console.log(JSON.stringify(txs, null, 2));
    });
program
    .command('mnemonic_transfer <from> <to> <amount>')
    .option('-d, --denom [simbol]', 'denomination of the transfer ("muon" default, "usd", ...)')
    .option('-n, --network [name]', 'Name of network ("gaia" or "columbus_2")')
    .action(async (from, to, amount, options) => {
        const { mnemonic } = db.get('addresses').find({ address: from }).value();
        console.log('mnemonic =', mnemonic);
        const privateKey = mnemonicToPrivateKey(mnemonic);
        console.log('privateKey =', privateKey);
        console.log(await mnemonicTransfer(privateKey.toString('hex'), from, to, amount, options.denom || 'umuon', options.network || 'gaia'));
    });

program
    .command('transfer <from> <to> <amount>')
    .option('-d, --denom [symbol]', 'denomination of the transfer ("luna" default, "usd", ...)')
    .option('-fd, --feedenom [symbol]', 'denomination of the fee ("luna" default, "usd", ...)')
    .option('-n, --network [name]', 'Name of network ("gaia" or "mainnet")')
    .option('-dr, --dry_run', 'Print the tx without posting it')
    .option('-all, --all', 'Transfer all the coins of the specified currency')
    .action(async (from, to, amount, options) => {
        await client.init();
        const sendOptions = {memo: options.memo, chainName: options.network, feeDenom: options.feedenom };
        await client.transfer(from, to, amount, options.denom || 'luna', sendOptions, options.all, options.dry_run);
    });

program.parse(process.argv);
